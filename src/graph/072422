use super::rules::Rules;
use super::vertex::*;
use crate::analyzer::taint::*;
use crate::tree::cursor::*;
use std::collections::HashMap;

pub struct Graph<'a> {
    nodes: HashMap<Cursor<'a>, Vertex<'a>>,
    leaves: HashMap<Taint, Vec<Cursor<'a>>>,
}

impl<'a> Graph<'a> {
    pub fn new() -> Self {
        Self {
            nodes: HashMap::new(),
            leaves: HashMap::new(),
        }
    }

    pub fn dump(&self) -> String {
        let mut s = format!("digraph {{\n");
        let mut i = 0;
        for (k, v) in self.nodes.iter() {
            s.push_str(&format!(
                "\t{i} [ label = \"{}\" ]\n",
                (&format!("{} [{:?}]", k.to_str(), v)).replace("\"", "\\\"")
            ));
            if let Some((parent, path)) = v.parents().iter().next() {
                for c in path.iter() {
                    let mut j = 0;
                    for (k, _) in self.nodes.iter() {
                        if c == k {
                            s.push_str(&format!("\t{j} -> {i} []\n"));
                        }
                        j += 1;
                    }
                }
            }
            i += 1;
        }
        s.push('}');
        s
    }

    /// call this as you pop context so that next time you step
    /// into that block, you have fresh taints
    pub fn clear_scope(&mut self, scope: &Scope) {
        for (t, v) in self.leaves.iter_mut() {
            if t.scope == *scope {
                *v = Vec::new();
            }
        }
    }

    // get rid of returns after using them, since they have global scope
    pub fn clear_returns(&mut self) {
        for (t, v) in self.leaves.iter_mut() {
            if t.kind == TaintKind::Return {
                *v = Vec::new();
            }
        }
    }

    // pub fn verts_to_path(&'a self, vert_path: Vec<Cursor<'a>>) -> Vec<Cursor<'a>> {
    //     let mut last_cur: Option<Cursor<'a>> = None;
    //     let mut out_path = Vec::new();
    //     for vert in vert_path.iter() {
    //         if let Some(vert_cur) = last_cur {
    //             let last = self.nodes.get(&vert_cur).unwrap();
    //             for (parent, path) in last.parents() {
    //                 if path.contains(vert) {
    //                     out_path.extend(path.path.clone());
    //                     break;
    //                 }
    //             }
    //         }
    //         last_cur = Some(vert.clone());
    //     }

    //     // if let Some(vert) = self.nodes.get(&vert_path.last().unwrap()) {
    //     //     for (item, path) in vert.paths.iter() {}
    //     // }

    //     out_path
    // }

    pub fn crawl_sinks(&'a self, ruleset: &Rules) -> Vec<Vec<Cursor<'a>>> {
        let mut paths = Vec::new();
        for (k, v) in self.nodes.iter() {
            for (parent, path) in v.parents().iter() {
                for cur in path.segments() {
                    let mut crawl = ruleset.sinks().contains_key(&k.name().unwrap_or_default());
                    if ruleset.sinks().contains_key(k.kind()) {
                        crawl = true;
                    }
                    if let Some(n) = cur.name() {
                        //println!("{:?}", ruleset.sinks());
                        if ruleset.sinks().contains_key(&n) {
                            crawl = true;
                        }
                    }
                    if ruleset.sinks().contains_key(cur.kind()) {
                        crawl = true;
                    }
                    if crawl {
                        let mut stack: Vec<Cursor> = vec![k.clone()];
                        for (parent, path) in v.parents().iter() {
                            stack.extend(path.path_vec().clone());
                            let new = self.defi_verts(&stack, parent);
                            paths.extend(new);
                        }
                    }
                }
                if let None = v.assign() {}
            }
        }
        paths
    }

    /*
    fn defi_verts(&'a self, stack: &Vec<Cursor<'a>>, last_cur: &'a Cursor) -> Vec<Vec<Cursor<'a>>> {
        let mut stacks = Vec::new();
        let mut stack = stack.clone();
        let last_vert = self.nodes.get(&last_cur).unwrap();
        let mut counter = 0;
        for (parent, path) in last_vert.parents().iter() {
            for sin parents.iter() {
                if stack.contains(parent) {
                    continue;
                }
                stack.push(parent.clone());
                stacks.extend(self.defi_verts(&stack, parent));
                stack.pop();
                counter += 1;
            }
            if counter == 0 && stack.len() > 0 {
                stacks.push(stack.clone());
            }
        }
        stacks
    }

    pub fn oracle(&self, ruleset: &Rules, vertices: &Vec<Cursor>) -> bool {
        let mut last_vert: Option<Vertex> = None;
        for vert_cur in vertices {
            let vert = self.nodes.get(vert_cur).unwrap();
            for (item, path) in vert.paths() {}
        }
    }

    pub fn test_path(&self, ruleset: &Rules, path: &Vec<Cursor>) -> bool {
        for segment in path.iter() {
            let segname = &segment.name().unwrap_or_default();
            let segkind = segment.kind();
            for (_kind, vuln) in ruleset.vulns().iter() {
                let mut cont = false;
                if vuln.sinks.contains_key(segname) {
                    cont = true;
                } else if vuln.sinks.contains_key(segkind) {
                    cont = true;
                }

                if cont {
                    for segment in path.iter() {
                        let vert = self.nodes.get(segment).unwrap();
                        for (parent, path) in vert.parents().iter() {
                            for segment in path.path.iter() {
                                let segname = &segment.name().unwrap_or_default();
                                let segkind = segment.kind();
                                if vuln.sanitizers.contains_key(segname)
                                    || vuln.sanitizers.contains_key(segkind)
                                {
                                    return false;
                                }
                            }
                            if vuln.sources.contains(&path.source.name) {
                                return true;
                            }
                        }
                    }
                }
            }
        }
        false
    }
    */
    /// push a taint to the graph
    /// returns true if the vertex is unknown
    /// return false if known to stop crawl
    pub fn push(&mut self, cursor: Cursor<'a>, vertex: Vertex<'a>) -> bool {
        let mut known = false;
        // if theres already a vertex at this node, add another
        // NO. BAD IDEA
        // add another path, much nicer
        if let Some(vert) = self.nodes.get_mut(&cursor) {
            // verts.push(vertex.clone());
            for (path, parents) in vertex.paths().iter() {
                vert.push(path.clone(), parents.clone());
            }
            known = true;
        } else {
            // otherwise insert
            self.nodes.insert(cursor.clone(), vertex.clone());
        }

        // okay now we need to connect this to its parents
        self.add_edges(cursor.clone());

        // and finally, update our leaves
        if let Some(assign) = vertex.assign() {
            if let Some(leaves) = self.leaves.get(&assign) {
                // the variable is already tainted, remove subtaints
                let mut newvec = vec![cursor.clone()];
                for leaf in leaves.iter() {
                    let leaf_ctx = &self.nodes.get(&leaf).unwrap().context();
                    if !vertex.context().contains(&leaf_ctx) {
                        newvec.push(leaf.clone());
                    }
                }
                self.leaves.insert(assign, newvec);
            } else {
                // this is our first time tainting this variable, new insert
                self.leaves.insert(assign, vec![cursor.clone()]);
            }
        }
        !known
    }

    fn add_edges(&mut self, cursor: Cursor<'a>) {
        let vertex = self.nodes.get_mut(&cursor).unwrap(); // we know this wont have an error since we just inserted to nodes
        for (path, parents) in vertex.paths().iter_mut() {
            let taint = &path.source;

            if let Some(leaves) = self.leaves.get(&taint) {
                for leaf in leaves.iter() {
                    if leaf != &cursor {
                        parents.insert(leaf.clone());
                    }
                }
            } else {
                // this just happens on sources, we can polish later
                //println!("{:?}", taint);
            }
        }
    }
}
